000100000 // r0 = 32
100010000 // r0 = mem[32]
100100001 // r1 = mem[32]
000000011 // r0 = 3
101010001 // r0 = mem[32] >> 3
100100111 // r7 = mem[32] >> 3 (pattern)
000000000 // r0 = 0
100100001 // r1 = i = 0
000100000 // LOOP1: r0 = 32
101011001 // if r1 < 32 then 1 else 0
110110000 // brr LOOP1_DONE
000000000 // r0 = 0
100100010 // r2 = location = 0
100100011 // r3 = count = 0
000000100 // WHILE1: r0 = 4
101011010 // if r2 < 4 then 1 else 0
110010011 // brr WHILE1_DONE
100010001 // r0 = mem[i]
100100100 // r4 = str = mem[i]
000000000 // r0 = 0
100000010 // r0 = location
101010100 // r0 = str >> location
100100100 // str = str >> location
000011111 // r0 = 31 ('b00011111)
100101100 // r0 = 'b00011111 & str
101100111 // if (r7 == r0) then 1 else 0
110000100 // brr IF1_DONE
000000001 // r0 = 1
100000011 // r0 = count + 1
100100011 // count = count + 1
000000001 // IF1_DONE: r0 = 1
100000010 // r0 = location + 1
100100010 // location = location + 1
101011000
111100000 // brl WHILE1
000000000 // WHILE1_DONE: r0 = 0
101100011 // if (count == 0) then 1 else 0
100100110 // r6 = if (count == 0) then 1 else 0
000000000 // r0 = 0
101100110 // if (r6 == 0) then 1 else 0
110001101 // brr IF2_DONE
000100001 // r0 = 33
100100101 // r5 = 33
100010000 // r0 = mem[33]
100000011 // r0 = mem[33] + count
100011101 // mem[33] = mem[33] + count
000000001 // r0 = 1
100100110 // r6 = 1
000100010 // r0 = 34
100100101 // r5 = 34
100010000 // r0 = mem[34]
100000110 // r0 = mem[34] + 1
100011101 // mem[34] = mem[34] + 1
000000001 // IF2_DONE: r0 = 1
100000001 // r0 = i + 1
100100001 // i = i + 1
101011000
111100001 // brl LOOP1
000000000 // LOOP1_DONE: r0 = 0
100100011 // count = 0
000000000 // r0 = 0
100100001 // r1 = i = 0
000011111 // LOOP2: r0 = 31
101011001 // if i < 31 then 1 else 0
110101000 // brr LOOP2_DONE
000000000 // r0 = 0
100100010 // r2 = location = 0
100010001 // r0 = mem[i]
100100100 // r4 = mem[i]
000000100 // r0 = 4
101001100 // r0 = mem[i] << 4
100100101 // r5 = low = mem[i] << 4
000000001 // r0 = 1
100000001 // r0 = i + 1
100010000 // r0 = mem[i+1]
100100100 // r4 = mem[i+1]
000000100 // r0 = 4
101010100 // r0 = mem[i+1] >> 4
100110101 // r0 = (mem[i+1] >> 4) | (mem[i] << 4)
100100101 // r5 = str = (mem[i+1] >> 4) | (mem[i] << 4)
000000100 // WHILE2: r0 = 4
101011010 // if (location < 4) then 1 else 0
110010001 // brr WHILE2_DONE
000000000 // r0 = 0
100000010 // r0 = location
101010101 // r0 = str >> location
100100100 // r4 = str >> location
000011111 // r0 = 31 ('b00011111)
100101100 // r0 = str = 'b00011111 & (str >> location)
101100111 // if (pattern == str):
110000100 // brr IF3_DONE
000000001 // r0 = 1
100000011 // r0 = count + 1
100100011 // count = count + 1
000000001 // IF3_DONE: r0 = 1
100000010 // r0 = location + 1
100100010 // location = location + 1
101011000
111100010 // brl WHILE2
000000001 // WHILE2_DONE: r0 = 1
100000001 // r0 = i + 1
100100001 // i = i + 1
101011000
111100011 // brl LOOP2
000100011 // LOOP2_DONE: r0 = 35
100100110 // r6 = 35
000100001 // r0 = 33
100010000 // r0 = mem[33]
100000011 // r0 = mem[33] + count
100011110 // data_mem[35] = mem[33] + count
101111111 // halt
